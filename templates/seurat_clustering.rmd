---
title: "snRNAseq workflow: dimensionality reduction and clustering"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
params:
  params_file: false
  rds_file: false
output:
  html_document:
    keep_md: true
    code_folding: show
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    number_sections: true
    theme: lumen
---

```{r initialise, include = F}
# magrittr, gridExtra, clustree, monocle3 must be loaded in the environment (due to package-specific bugs)
library(clustree)
library(gridExtra)
library(monocle3)
library(magrittr)

# load params file
curr_params <- 
  rjson::fromJSON(file = params$params_file) %>% 
  type.convert(as.is = T)

# set seed for repeatability
set.seed(42)
random_seed = 42

# set ggplot presets
ggplot2::theme_set(ggplot2::theme_bw())
ggplot2::theme_update(legend.text = ggplot2::element_text(size = 7))
ditto_colours <- list(ggplot2::scale_fill_manual(values = dittoSeq::dittoColors(), na.value = "white"),
                      ggplot2::scale_colour_manual(values = dittoSeq::dittoColors(), na.value = "white"))
umap_void_theme <-
  ggplot2::theme(axis.text = ggplot2::element_blank(),
                 axis.title = ggplot2::element_blank(),
                 axis.ticks = ggplot2::element_blank(),
                 legend.position = "none",
                 plot.margin = ggplot2::unit(c(2,2,2,2), "pt"))

# chunk setup
knitr::opts_chunk$set(fig.align = "center",
                      dpi = 300)

# reductions
redus <- c("PCA", "UMAP")

# get reduced cell types
get_singler_annot_reduced <-	function(x){
  x$singler_annot_reduced <- x$singler_annot_main
  
  replacements <-
    list(
      "Epithelial_cells" = c("Epithelial_cells", "Neuroepithelial_cell"),
      "T&NK_cells" = c("T_cells", "NK_cell"),
      "B_cells" = c("B_cell", "Pre-B_cell_CD34-", "Pro-B_cell_CD34+"),
      "Erythrocytes" = c("Erythroblast", "Platelets", "MEP"),
      "Myeloid_cells" = c("Pro-Myelocyte",	"Myelocyte", "Neutrophils", "Monocyte", "Macrophage", "DC", "CMP", "GMP"),
      "Tissue_stem_cells" = c("Tissue_stem_cells", "iPS_cells", "Embryonic_stem_cells", "HSC_CD34+", "MSC", "HSC_-G-CSF"),
      "Others" = c("Keratinocytes",	"Hepatocytes", "Gametocytes", "BM & Prog.", "BM", "Neurons", "Astrocyte", "Chondrocytes", "Osteoblasts")
    ) %>%
    tibble::enframe(name = "label.reduced", value = "label.main") %>%
    tidyr::unnest(cols = "label.main")
  
  tibble::tibble(singler_annot_fine = x) %>%
    dplyr::left_join(replacements) %>%
    dplyr::mutate(
      singler_annot_reduced = dplyr::case_when(
        is.na(singler_annot_reduced) ~ singler_annot_main,
        TRUE ~ singler_annot_reduced
      )
    )
}

# calculate plot height for grids
get_fig_dims <- function(n_plots, n_cols = NULL, grid_width = 10, height_to_width_ratio = 1) {
  # get dims
  dims <- ggplot2::wrap_dims(n_plots, n_cols)
  # get scale
  scale <- grid_width / dims[1]
  # get height
  grid_height <- (dims[2] * scale) * height_to_width_ratio
  # return dims
  c(grid_width, grid_height)
}

# dev.off() if there is a device
dev_off_if <- function() {if (length(dev.list()) != 0) { dev.off() }}

# Get cluster centroids from a Seurat or cell_data_set object
get_centroids <- function(object, reduction, lvl) {

  if (class(object)[1] == "Seurat") {
    embeddings <- object@reductions[[reduction]]@cell.embeddings
    metadata <- object@meta.data
  } else if (class(object)[1] == "cell_data_set") {
    embeddings <- SingleCellExperiment::reducedDims(object)[[reduction]]
    metadata <- SummarizedExperiment::colData(object) %>% dplyr::as_tibble()
  }

  dplyr::tibble(
    x = embeddings[,1],
    y = embeddings[,2],
    metadata
  ) %>%
    dplyr::group_by(get(lvl)) %>%
    dplyr::summarise(x = median(x), y = median(y)) %>%
    dplyr::rename(!!lvl := `get(lvl)`)

}
```

# Dimensionality reduction and clustering

## Linear dimensionality reduction

```{r lin_dim_red, echo = F}
seu <- readRDS(params$rds_file)
seu <- xfun::cache_rds({
  seu <- Seurat::FindVariableFeatures(seu)
  seu <- Seurat::SCTransform(seu)
  seu <- Seurat::CellCycleScoring(
    seu,
    s.features = Seurat::cc.genes$s.genes,
    g2m.features = Seurat::cc.genes$g2m.genes
  )
  seu <- Seurat::RunPCA(seu)
  seu
}, file = "seu_pca.rds")
```

## Dimensionality of the data

```{r usr_n_dims_msg, echo = F, eval = curr_params$cluster$n_dims != F, results = 'asis'}
cat("### Manually\n")
cat(paste0("Dimensionality of the data is **", curr_params$cluster$n_dims, "** (set by argument n_dims).\n"))
```

```{r usr_n_dims, include = curr_params$cluster$n_dims != F, eval = curr_params$cluster$n_dims != F}
final_n_dims <- curr_params$cluster$n_dims
```

### intrinsicDimension

```{r iD_msg, echo = F, eval = curr_params$cluster$n_dims == F, results = 'asis'}
cat("No value was provided for `n_dims`, so dimensionality will be calculated using the intrinsicDimensions package.\n")
```

The dimensionality of the dataset can be estimated using the `intrinsicDimension` package. This bypasses the manual approach of reading the elbow plot, but can sometimes be a bit too conservative. Therefore, if `n_dims` is not defined by the user, the dimensionality is set as 1.5 x `intrinsicDimension` estimate. 

```{r iD_n_dims}
iD_n_dims <- xfun::cache_rds({
  intrinsicDimension::maxLikGlobalDimEst(
    seu@reductions$pca@cell.embeddings,
    k = 10
  )$dim.est %>% round(0)
}, file = "iD_n_dims.rds")
generous_n_dims <- round(1.5 * ifelse(iD_n_dims == 0, 1, iD_n_dims), 0)
```

```{r iD_n_dims_set, include = curr_params$cluster$n_dims == FALSE, eval = curr_params$cluster$n_dims == FALSE}
final_n_dims <- generous_n_dims
```

Dimensionality set to **`r final_n_dims`**.

```{r elbow_plot, class.source = 'fold-hide', fig.cap = "Elbow plot"}
p <-
  Seurat::ElbowPlot(seu, ndims = max(50, final_n_dims)) &
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = final_n_dims,
                 colour = ifelse(curr_params$cluster$n_dims == F, "chosen n_dims", "user-provided n_dims")),
                 linewidth = 1) &
  ggplot2::geom_vline(ggplot2::aes(xintercept = iD_n_dims, colour = "intrisicDimensions"),
                      linewidth = 1, linetype = "dashed") &
  ggplot2::geom_vline(ggplot2::aes(xintercept = generous_n_dims, colour = "generous (iD x 1.5)"),
                      linewidth = 1, linetype = "dashed") &
  ggplot2::scale_colour_manual(
    name = "n_dims cut-off",
    values = c(`chosen n_dims` = dittoSeq::dittoColors()[[1]],
               `user-provided n_dims` = dittoSeq::dittoColors()[[1]],
               intrisicDimensions = dittoSeq::dittoColors()[[2]],
               `generous (iD x 2)` = dittoSeq::dittoColors()[[3]])) &
  ggplot2::theme(legend.position = c(0.7, 0.9),
                 legend.background = ggplot2::element_rect(fill = "white"))
p
```

## Non-linear dimensionality reduction and clustering

```{r clustering_and_umap, echo = F}
seu <- xfun::cache_rds({
  seu <- Seurat::FindNeighbors(seu, dims = 1:final_n_dims)
  clustering_resolutions <- seq(0.1, 0.8, by = 0.1)
  seu <- Seurat::FindClusters(seu, resolution = clustering_resolutions)
  seu <- Seurat::RunUMAP(seu, dims = 1:final_n_dims)
  seu
}, file = "seu_clustered.rds")

# save clustered
saveRDS(seu, "seu_clustered.rds")
```

### Groupings vs reductions

```{r get_groupings, include = F, echo = F}
# sample_metadata columns with >1 value that are not `dir` or `file_prefix`
groupings <- 
  seu@misc$sample_metadata %>%
  dplyr::select(where(~ dplyr::n_distinct(.x) > 1)) %>%
  dplyr::select(-tidyr::any_of(c("dir", "file_prefix"))) %>%
  colnames()
```

```{r groupings_vs_reductions, echo = F, fig.dim = get_fig_dims(n_plots = 3 * length(groupings), n_cols = 3), fig.cap = "Plot of all monocle3 dimensionality reductions, coloured by groupings", eval = (nrow(seu@misc$sample_metadata) > 1) == T}
# plot all groupings vs all reductions
groupings_vs_reductions <- list()
purrr::walk(groupings, function(grouping) {
  purrr::walk(redus, function(redu) {
    if (dplyr::n_distinct(seu@meta.data[, grouping]) > 1) {
      title <- paste0(redu, "_vs_", grouping)
      p <- 
        Seurat::DimPlot(
          seu, 
          group.by = grouping, 
          reduction = tolower(redu),
          cols = dittoSeq::dittoColors()
        )
      groupings_vs_reductions[[paste0(grouping, "_legend")]] <<-
        lemon::g_legend(p)
      groupings_vs_reductions[[title]] <<- 
        p & Seurat::NoLegend()
    }
  })
})
# create grob layout
p <-
  gridExtra::marrangeGrob(
    grobs = groupings_vs_reductions,
    nrow = length(groupings),
    ncol = length(redus) + 1,
    layout_matrix = matrix(
      1:length(groupings_vs_reductions),
      length(groupings),
      length(redus) + 1,
      TRUE
    ),
    top = NULL
  )
p
```

### Resolutions vs reductions

```{r resolutions_vs_reductions, echo = F, fig.dim = c(10, 40)}
resolutions_vs_reductions <- list()
purrr::walk(clustering_resolutions, function(res) {
  purrr::walk(Seurat::Reductions(seu), function(redu) {
      title <- paste0(redu, "_by_cluster_res_", res)
      resolutions_vs_reductions [[title]] <<-
        dittoSeq::dittoDimPlot(
          seu,
          paste0(Seurat::DefaultAssay(seu), "_snn_res.", res),
          reduction.use = redu,
          size = 0.5,
          raster = F,
          legend.show = F,
          show.axes.numbers = F,
          show.grid.lines = F,
          main = gsub("_", " ", title)
        )
    })
})
# create grob layout
p <-
  gridExtra::marrangeGrob(
    grobs = resolutions_vs_reductions ,
    nrow = length(clustering_resolutions),
    ncol = length(Seurat::Reductions(seu)),
    layout_matrix = matrix(1:length(resolutions_vs_reductions ),
                           length(clustering_resolutions),
                           length(Seurat::Reductions(seu)),
                           TRUE),
    top = NULL
  )
p
```

### Clustering tree

```{r clustering_tree, echo = F, fig.cap = "Plot of clustering tree"}
snn_res_prefixes <- paste0(Seurat::DefaultAssay(seu), "_snn_res.")
p <- 
  clustree::clustree(seu@meta.data[, grep(snn_res_prefixes, colnames(seu@meta.data))],
                       prefix = snn_res_prefixes)
p
```

# Celltype annotation

## SingleR

```{r singler_annots, message = F, warning = F}
# get reference from celldex
singler_refs <- celldex::HumanPrimaryCellAtlasData() 

# get singler annots, reduce main labels  
singler_annots <- xfun::cache_rds({
  singler_annots <- 
    SingleR::SingleR(
      test = SeuratWrappers::as.cell_data_set(seu, assay = "RNA")@assays@data$counts,
      ref = singler_refs,
      labels = singler_refs@colData$label.fine
    ) %>%
    tibble::as_tibble() %>%
    dplyr::select(label.fine = pruned.labels) %>%
    dplyr::left_join(
      singler_refs@colData %>%
        tibble::as_tibble() %>%
        dplyr::select(label.main, label.fine) %>%
        dplyr::distinct()
    ) %>%
    dplyr::left_join(
       list(
            "Epithelial_cells" = c("Epithelial_cells", "Neuroepithelial_cell"),
            "T&NK_cells" = c("T_cells", "NK_cell"),
            "B_cells" = c("B_cell", "Pre-B_cell_CD34-", "Pro-B_cell_CD34+"),
            "Erythrocytes" = c("Erythroblast", "Platelets", "MEP"),
            "Myeloid_cells" = c("Pro-Myelocyte",	"Myelocyte", "Neutrophils", "Monocyte", "Macrophage", "DC", "CMP", "GMP"),
            "Tissue_stem_cells" = c("Tissue_stem_cells", "iPS_cells", "Embryonic_stem_cells", "HSC_CD34+", "MSC", "HSC_-G-CSF"),
            "Others" = c("Keratinocytes",	"Hepatocytes", "Gametocytes", "BM & Prog.", "BM", "Neurons", "Astrocyte", "Chondrocytes", "Osteoblasts")
          ) %>%
          tibble::enframe(name = "label.reduced", value = "label.main") %>%
          tidyr::unnest(cols = "label.main")
    ) %>%
    dplyr::mutate(
      label.reduced = dplyr::case_when(is.na(label.reduced) & is.na(label.main) ~ "Other",
                                       is.na(label.reduced) ~ label.main,
                                       TRUE ~ label.reduced))
  singler_annots
}, file = "singler_annots.rds")
saveRDS(singler_annots, "singler_annots.rds")

# add to seurat object
seu@meta.data <-
  cbind(seu@meta.data,
        singler_annots)
seu <- Seurat::SetIdent(seu, value = "label.reduced")
saveRDS(seu, "seu_singler_annotated.rds")
```

```{r plot_main}
Seurat::DimPlot(seu, label = T , repel = T, label.size = 3) &
  ditto_colours()
```

## Malignancy and differentiation scores (from Zhang et al., 2021)

```{r malig_and_diff_scores}
# switch default assay to RNA
Seurat::DefaultAssay(seu) <- "RNA"
malignancy_genes <-
  readr::read_tsv(params$annotate$malignancy_score_file) %>%
  dplyr::transmute(gene, 
                   population = dplyr::case_when(logFC > 0 ~ "malignant",
                                                 TRUE ~ "nonmalignant")) %>%
  {split(.$gene, .$population)} %>%
  {c(., list("differentiation" = c("KRT20", "PHGR1", "MDK", "CHDR2", "RARRES3", "GPA33", "SLC5A1", "MUC13")))}
seu <- 
  Seurat::AddModuleScore(
    seu, 
    assay = "RNA", 
    features = malignancy_genes, 
    name = names(malignancy_genes)
  )

# malignancy score = malignant score - nonmalignant score
seu$malignancy <- seu$malignant1 - seu$nonmalignant2

# differentiation score
seu$differentiation <- seu$differentiation3
seu$differentiation3 <- NULL
```

```{r malig_and_diff_plots, echo = F}
Seurat::FeaturePlot(seu, features = c("malignancy", "differentiation")) & 
  ggplot2::scale_colour_gradientn(colours = rev(RColorBrewer::brewer.pal(n = 11, name = "RdBu")))
```

```{r plot_malignacy_vs_nonmalignancy, echo  F}
seu@meta.data %>% 
  ggplot2::ggplot(ggplot2::aes(x = malignant1, y = nonmalignant2, colour = malignancy)) +
  ggplot2::geom_point() + 
  ggplot2::theme_classic() +
seu@meta.data %>%
  ggplot2::ggplot(ggplot2::aes(x = malignancy, y = differentiation)) +
  ggplot2::geom_point() + 
  ggplot2::theme_classic()
```

```{r save_annotated}
saveRDS(seu, "seu_annotated.rds")
```

## Canonical celltype markers

```{r avail_markers}
# load markers
markers <-
  curr_params$annotate$markers_file %>%
  readr::read_tsv(show_col_types = F) %>%
  {split(.$gene, .$population)}
# get markers present in the dataset
avail_markers <- markers %>% purrr::map(intersect, rownames(seu))
```

```{r canonical_marker_expr}
p <-
  avail_markers %>%
  names() %>%
  purrr::map(function(ct) {
    p <-
      seu %>%
      Nebulosa::plot_density(avail_markers[[ct]], joint = T) +
      patchwork::plot_layout(ncol = 1)
  }) %>%
  setNames(names(avail_markers))
# create grob layout
p <-
  gridExtra::marrangeGrob(
    grobs = p,
    nrow = length(p),
    ncol = 1
  )
```

```{r knit_density_plots}
to_knit <- c()

for(ct in names(avail_markers)) {
  
  to_knit <- c(to_knit, paste0("\n##### Population: **", ct, "**\n"))
  chunk_name_ct <- ct %>% janitor::make_clean_names()
  n_ct_markers <- length(avail_markers[[ct]])

  knit_module_dimplots <- c(
    '',
    paste0("```{r ', chunk_name_ct, ', echo = F, warning = F, message = F, fig.dim = get_fig_dims(", n_ct_markers + 1, ", n_cols = 1, height_to_width_ratio = 1.2)}"),
    paste0("p <- seu %>% Nebulosa::plot_density(avail_markers[['", ct, "']], joint = T) + patchwork::plot_layout(ncol = 1)"),
    'p',
    '```',
    ''
    )

  dev_off_if()
  knitted_module_dimplots <- knitr::knit_child(text = knit_module_dimplots, envir = environment(), quiet = TRUE)
  dev_off_if()
  to_knit <- c(to_knit, knitted_module_dimplots)

}
dev_off_if()
cat(unlist(to_knit), sep = '\n')
```


