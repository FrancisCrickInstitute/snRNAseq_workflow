---
title: "snRNAseq workflow: celltype annotation"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
params:
  params_file: false
  rds_file: false
output:
  html_document:
    keep_md: true
    code_folding: show
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    number_sections: true
    theme: lumen
---

```{r initialise, include = F}
# magrittr, gridExtra, clustree, monocle3 must be loaded in the environment (due to package-specific bugs)
library(gridExtra)
library(monocle3)
library(magrittr)

# load params file
# base_dir=ifelse(Sys.info()["nodename"]=="Alexs-MacBook-Air-2.local","/Volumes/TracerX/","/camp/project/tracerX/");setwd(paste0(base_dir,"working/VHL_GERMLINE/tidda/snRNAseq_workflow/"))
# cluster: # params <- list(params_file = "output/params.json")
# local:   # params <- list(params_file = "test/local_params.json")
curr_params <- 
  rjson::fromJSON(file = params$params_file) %>% 
  type.convert(as.is = T)

# set seed for repeatability
set.seed(42)
random_seed = 42

# set ggplot presets
ggplot2::theme_set(ggplot2::theme_bw())
ggplot2::theme_update(legend.text = ggplot2::element_text(size = 7))
ditto_colours <- list(ggplot2::scale_fill_manual(values = dittoSeq::dittoColors(), na.value = "white"),
                      ggplot2::scale_colour_manual(values = dittoSeq::dittoColors(), na.value = "white"))
umap_void_theme <-
  ggplot2::theme(axis.text = ggplot2::element_blank(),
                 axis.title = ggplot2::element_blank(),
                 axis.ticks = ggplot2::element_blank(),
                 legend.position = "none",
                 plot.margin = ggplot2::unit(c(2,2,2,2), "pt"))

# chunk setup
knitr::opts_chunk$set(fig.align = "center",
                      dpi = 300)
```

```{r define_functions, include = F, eval = T}
# dev.off() if there is a device
dev_off_if <- function() {if (length(dev.list()) != 0) { dev.off() }}

# flatten lists
flatten_list <- function (x, use.names = TRUE, classes = "ANY") 
{
    len <- sum(rapply(x, function(x) 1L, classes = classes))
    y <- vector("list", len)
    i <- 0L
    items <- rapply(x, function(x) {
        i <<- i + 1L
        y[[i]] <<- x
        TRUE
    }, classes = classes)
    if (use.names && !is.null(nm <- names(items))) 
        names(y) <- nm
    y
}

#' Identify the genes most specifically expressed in groups of cells
#'
#' @param cds A cell_data_set object to calculate top markers for.
#' @param group_cells_by String indicating what to group cells by for
#'   comparison. Default is "cluster".
#' @param genes_to_test_per_group Numeric, how many genes of the top ranked
#'   specific genes by Jenson-Shannon to do the more expensive regression test
#'   on.
#' @param reduction_method String indicating the method used for dimensionality
#'   reduction. Currently only "UMAP" is supported.
#' @param marker_sig_test A flag indicating whether to assess the discriminative
#' power of each marker through logistic regression. Can be slow, consider
#' disabling to speed up top_markers().
#' @param reference_cells If provided, top_markers will perform the marker
#' significance test against a "reference set" of cells. Must be either a list
#' of cell ids from colnames(cds), or a positive integer. If the latter, top_markers()
#' will randomly select the specified number of reference cells. Accelerates
#' the marker significance test at some cost in sensitivity.
#' @param speedglm.maxiter Maximum number of iterations allowed for fitting GLM
#' models when testing markers for cell group.
#' @param cores Number of cores to use.
#' @param verbose Whether to print verbose progress output.
#'
#' @return a data.frame where the rows are genes and the columns are
#' * gene_id vector of gene names
#' * gene_short_name vector of gene short names
#' * cell_group character vector of the cell group to which the cell belongs
#' * marker_score numeric vector of marker scores as the fraction expressing scaled by the specificity. The value ranges from 0 to 1.
#' * mean_expression numeric vector of mean normalized expression of the gene in the cell group
#' * fraction_expressing numeric vector of fraction of cells expressing the gene within the cell group
#' * specificity numeric vector of a measure of how specific the gene's expression is to the cell group based on the Jensen-Shannon divergence. The value ranges from 0 to 1.
#' * pseudo_R2 numeric vector of pseudo R-squared values, a measure of how well the gene expression model fits the categorical data relative to the null model. The value ranges from 0 to 1.
#' * marker_test_p_value numeric vector of likelihood ratio p-values
#' * marker_test_q_value numeric vector of likelihood ratio q-values
#'
#' @examples
#'   \donttest{
#'     library(dplyr)
#'
#'     cell_metadata <- readRDS(system.file('extdata',
#'                                          'worm_embryo/worm_embryo_SummarizedExperiment::colData.rds',
#'                                          package='monocle3'))
#'     gene_metadata <- readRDS(system.file('extdata',
#'                                          'worm_embryo/worm_embryo_SummarizedExperiment::rowData.rds',
#'                                          package='monocle3'))
#'     expression_matrix <- readRDS(system.file('extdata',
#'                                              'worm_embryo/worm_embryo_expression_matrix.rds',
#'                                              package='monocle3'))
#'
#'     cds <- new_cell_data_set(expression_data=expression_matrix,
#'                              cell_metadata=cell_metadata,
#'                              gene_metadata=gene_metadata)
#'
#'     cds <- preprocess_cds(cds)
#'     cds <- reduce_dimension(cds)
#'     cds <- cluster_cells(cds)
#'     marker_test_res <- top_markers(cds, group_cells_by="partition", reference_cells=1000)
#'     top_specific_markers <- marker_test_res %>%
#'                              filter(fraction_expressing >= 0.10) %>%
#'                              group_by(cell_group) %>%
#'                              top_n(1, pseudo_R2)
#'     top_specific_marker_ids <- unique(top_specific_markers %>% pull(gene_id))
#'   }
#'
#' @importFrom dplyr n
#' @export
top_markers_develop <- function(cds,
                        group_cells_by="cluster",
                        genes_to_test_per_group=25,
                        reduction_method="UMAP",
                        marker_sig_test=TRUE,
                        reference_cells=NULL,
                        speedglm.maxiter=25,
                        cores=1,
                        verbose=FALSE) {
  # testing: # group_cells_by="partition";genes_to_test_per_group=25;reduction_method="UMAP";marker_sig_test=TRUE;reference_cells=NULL;speedglm.maxiter=25;cores=1;verbose=FALSE
  rowname <- cell_group <- marker_score <- cell_id <- mean_expression <- NULL # no visible binding
  fraction_expressing <- specificity <- pseudo_R2 <- NULL # no visible binding
  lrtest_p_value <- lrtest_q_value <- gene_short_name <- NULL # no visible binding

  # Yes, it's stupid we have cell ids both as a column and as the rownames.
  cell_group_df <- data.frame(row.names=row.names(SummarizedExperiment::colData(cds)),
                              cell_id=row.names(SummarizedExperiment::colData(cds)))

  # Set up the table that partitions the cells into groups.
  # Must be either a column in SummarizedExperiment::colData or one of "cluster" or "partition.
  # FIXME: Should check its not a column you can't really use for grouping
  # (i.e. a floating point value)
  if (group_cells_by == "cluster"){
    cell_group_df$cell_group <-
      tryCatch({monocle3::clusters(cds, reduction_method = reduction_method)},
               error = function(e) {NULL})
  } else if (group_cells_by == "partition") {
    cell_group_df$cell_group <-
      tryCatch({monocle3::partitions(cds, reduction_method = reduction_method)},
               error = function(e) {NULL})
  } else{
    cell_group_df$cell_group <- SummarizedExperiment::colData(cds)[,group_cells_by]
  }
  cell_group_df$cell_group <- as.character(cell_group_df$cell_group)

  if (verbose)
    message("Aggregating gene expression values for groups")
  # For each gene compute the fraction of cells expressing it within each group
  # in a matrix thats genes x cell groups

  cluster_binary_exprs = as.matrix(monocle3::aggregate_gene_expression(cds,
                                                             cell_group_df=cell_group_df,
                                                             norm_method="binary",
                                                             scale_agg_values=FALSE))

  cluster_mean_exprs = as.matrix(monocle3::aggregate_gene_expression(cds,
                                                           cell_group_df=cell_group_df,
                                                           norm_method="size_only",
                                                           scale_agg_values=FALSE))

  if (verbose)
    message("Computing Jensen-Shannon specificities")

  # Now compute a Jensen Shannon specificity score for each gene w.r.t each group
  cluster_spec_mat = specificity_matrix(cluster_mean_exprs, cores=cores)
  cluster_marker_score_mat = as.matrix(cluster_binary_exprs * cluster_spec_mat)

  if (verbose)
    message("Gathering score tables")
  cluster_marker_score_table = tibble::rownames_to_column(as.data.frame(cluster_marker_score_mat))
  cluster_marker_score_table = tidyr::gather(cluster_marker_score_table, "cell_group", "marker_score", -rowname)

  cluster_spec_table = tibble::rownames_to_column(as.data.frame(cluster_spec_mat))
  cluster_spec_table = tidyr::gather(cluster_spec_table, "cell_group", "specificity", -rowname)

  cluster_expr_table = tibble::rownames_to_column(as.data.frame(cluster_mean_exprs))
  cluster_expr_table = tidyr::gather(cluster_expr_table, "cell_group", "mean_expression", -rowname)

  cluster_fraction_expressing_table = tibble::rownames_to_column(as.data.frame(cluster_binary_exprs))
  cluster_fraction_expressing_table = tidyr::gather(cluster_fraction_expressing_table, "cell_group", "fraction_expressing", -rowname)

  # spec_model_df = data.frame(rowname=row.names(cluster_spec_score_mat),
  #                            num_expressing=Matrix::rowSums(SingleCellExperiment::counts(cds) > 0),
  #                            mean_exprs=Matrix::rowMeans(cluster_agg_exprs),
  #                            max_spec=rowMaxs(cluster_spec_score_mat))

  # # Now compute the expected max specificity as a function of how many cells express a given gene
  # # Genes that are expressed in few cells tend to have very high specificity, so we want to
  # # control for this trend when ranking genes by specificity later on
  # spec_model_df = spec_model_df %>% dplyr::mutate(quantile = dplyr::ntile(num_expressing, expression_bins))
  # spec_summary = spec_model_df %>% dplyr::group_by(quantile) %>% dplyr::summarize(log_spec_mean = mean(log(max_spec)), log_spec_sd = sd(log(max_spec)))
  # spec_model_df = dplyr::left_join(spec_model_df, spec_summary)
  #
  # # Compute the "specifity above expectation" for each gene w.r.t. each group:
  # cluster_spec_table = dplyr::left_join(cluster_spec_table, spec_model_df)
  # cluster_spec_table = cluster_spec_table %>% dplyr::mutate(log_spec=log(specificity),
  #                                                    pval_excess_spec = pnorm(log(specificity),log_spec_mean, log_spec_sd, lower.tail=FALSE))

  cluster_marker_score_table$specificity = cluster_spec_table$specificity
  cluster_marker_score_table$mean_expression = cluster_expr_table$mean_expression
  cluster_marker_score_table$fraction_expressing = cluster_fraction_expressing_table$fraction_expressing

  cluster_marker_score_table = cluster_marker_score_table %>%
    #filter(num_expressing > 10) %>%
    dplyr::group_by(cell_group) %>%
    dplyr::top_n(genes_to_test_per_group, marker_score)

  cell_group_df$cell_id <- as.character(cell_group_df$cell_id)
  cell_group_df$cell_group <- as.character(cell_group_df$cell_group)


  if (marker_sig_test){
    if (verbose)
      message("Running marker significance tests")
    # Temporarily disable OpenMP threading in functions to be run in parallel
    old_omp_num_threads = as.numeric(Sys.getenv("OMP_NUM_THREADS"))
    if (is.na(old_omp_num_threads)){
      old_omp_num_threads = 1
    }
    RhpcBLASctl::omp_set_num_threads(1)

    # Temporarily set the number of threads the BLAS library can use to be 1
    old_blas_num_threads = as.numeric(Sys.getenv("OPENBLAS_NUM_THREADS"))
    if (is.na(old_omp_num_threads)){
      old_blas_num_threads = 1
    }
    RhpcBLASctl::blas_set_num_threads(1)

    # Set up a balanced "reference" panel of cells from each group
    if (is.null(reference_cells) == FALSE){
      if(is.numeric(reference_cells)){
        num_ref_cells_per_group = reference_cells / length(unique(cell_group_df$cell_group))
        reference_cells = cell_group_df %>% dplyr::group_by(cell_group) %>%
          dplyr::sample_n(min(num_ref_cells_per_group, dplyr::n())) %>%
          dplyr::pull(cell_id)
        #reference_cells = sample(colnames(cds), reference_cells)
      } else {
        # TODO: check that reference cells is a list of valid cell ids.
      }
    }

    marker_test_res = tryCatch({pbmcapply::pbmcmapply(test_marker_for_cell_group,
                                                      cluster_marker_score_table$rowname,
                                                      cluster_marker_score_table$cell_group,
                                                      MoreArgs=list(cell_group_df, cds, reference_cells,
                                                                    speedglm.maxiter),
                                                      ignore.interactive = TRUE,
                                                      mc.cores=cores)},
                               finally = {
                                 RhpcBLASctl::omp_set_num_threads(old_omp_num_threads)
                                 RhpcBLASctl::blas_set_num_threads(old_blas_num_threads)
                               })

    #
    # Check for possible convergence failure or other problems. Issue: #383
    #
    if('warning' %in% names(marker_test_res)) {
      warning('test_marker_for_cell_group() caught warning: possible convergence failure.')
      warning(names(marker_test_res))
      marker_test_res <- marker_test_res[["value"]]
    }

    marker_test_res = t(marker_test_res)
    marker_test_res = as.matrix(marker_test_res)
    colnames(marker_test_res) = c("pseudo_R2", "lrtest_p_value")

    #marker_test_res = as.data.frame(marker_test_res)

    marker_test_res = dplyr::bind_cols(cluster_marker_score_table, as.data.frame(marker_test_res))
    marker_test_res$lrtest_q_value = stats::p.adjust(marker_test_res$lrtest_p_value,
                                                     method="bonferroni",
                                                     n=length(cluster_spec_mat))
    marker_test_res = marker_test_res %>% dplyr::select(rowname,
                                                        cell_group,
                                                        marker_score,
                                                        mean_expression,
                                                        fraction_expressing,
                                                        specificity,
                                                        pseudo_R2,
                                                        lrtest_p_value,
                                                        lrtest_q_value)

    marker_test_res = marker_test_res %>% dplyr::rename(gene_id=rowname, marker_test_p_value=lrtest_p_value,  marker_test_q_value=lrtest_q_value)
    marker_test_res$pseudo_R2 = unlist(marker_test_res$pseudo_R2)
    marker_test_res$marker_test_p_value = unlist(marker_test_res$marker_test_p_value)
    if ("gene_short_name" %in% colnames(SummarizedExperiment::rowData(cds))){
      marker_test_res = SummarizedExperiment::rowData(cds) %>%
        as.data.frame %>%
        tibble::rownames_to_column() %>%
        dplyr::select(rowname, gene_short_name) %>%
        dplyr::inner_join(marker_test_res, by=c("rowname"="gene_id"))
      marker_test_res = marker_test_res %>% dplyr::rename(gene_id=rowname)
    }
  } else {
    marker_test_res = cluster_marker_score_table
    marker_test_res = marker_test_res %>% dplyr::rename(gene_id=rowname)
  }

  if (verbose)
    message("Done")

  return(marker_test_res)
}


# Calculate the probability vector
makeprobsvec <- function(p) {
  phat <- p/sum(p)
  phat[is.na(phat)] = 0
  phat
}

# Calculate the probability matrix for a relative abundance matrix
makeprobs <- function(a) {
  colSums<-apply(a,2,sum)
  b <- Matrix::t(Matrix::t(a)/colSums)
  b[is.na(b)] = 0
  b
}

# Calculate the Shannon entropy based on the probability vector
shannon.entropy <- function(p) {
  if (min(p) < 0 || sum(p) <=0)
    return(Inf)
  p.norm <- p[p>0]/sum(p)
  -sum(log2(p.norm)*p.norm)
}

# Calculate the Jessen-Shannon distance for two probability distribution
JSdistVec <- function (p, q)
{
  JSdiv <- shannon.entropy((p + q)/2) - (shannon.entropy(p) +
                                           shannon.entropy(q)) * 0.5
  JSdiv[is.infinite(JSdiv)] <- 1
  JSdiv[JSdiv < 0] <- 0
  JSdist <- sqrt(JSdiv)
  JSdist
}

specificity_matrix <- function(agg_expr_matrix, cores=1){
  if(ncol(agg_expr_matrix) < 1) warning('bad loop: ncol(agg_expr_matrix) < 1')
  specificity_mat <-
    pbmcapply::pbmclapply(row.names(agg_expr_matrix),
                          FUN = function(x) {
                            agg_exprs = as.numeric(agg_expr_matrix[x,])
                            agg_exprs = makeprobsvec(agg_exprs)
                            perfect_spec_matrix = diag(ncol(agg_expr_matrix))
                            sapply(1:ncol(agg_expr_matrix), function(col_idx) {
                              1 - JSdistVec(agg_exprs,
                                            perfect_spec_matrix[,col_idx])
                            })
                          }, mc.cores=cores,
                          ignore.interactive = TRUE)
  specificity_mat = do.call(rbind, specificity_mat)
  colnames(specificity_mat) = colnames(agg_expr_matrix)
  row.names(specificity_mat) = row.names(agg_expr_matrix)
  return(specificity_mat)
  #
}

enrichment_matrix <- function(agg_expr_matrix, cores=1){
  if(ncol(agg_expr_matrix) < 1) warning('bad loop: ncol(agg_expr_matrix) < 1')
  specificity_mat = pbmcapply::pbmclapply(row.names(agg_expr_matrix),
                                          FUN = function(x)
                                          {
                                            agg_exprs = as.numeric(agg_expr_matrix[x,])
                                            agg_exprs = makeprobsvec(agg_exprs)
                                            perfect_spec_matrix = diag(ncol(agg_expr_matrix))
                                            sapply(1:ncol(agg_expr_matrix), function(col_idx) {
                                              1 - JSdistVec(agg_exprs, perfect_spec_matrix[,col_idx])
                                            }
                                            )
                                          }, mc.cores=cores,
                                          ignore.interactive = TRUE)
  specificity_mat = do.call(rbind, specificity_mat)
  colnames(specificity_mat) = colnames(agg_expr_matrix)
  row.names(specificity_mat) = row.names(agg_expr_matrix)
  return(specificity_mat)
  #
}

test_marker_for_cell_group = function(gene_id, cell_group, cell_group_df, cds,
                                      reference_cells=NULL, speedglm.maxiter=25){
  #print(gene_id)
  #print(cell_group)
  #print (length(reference_cells))
  results <- tryCatch({
    f_expression <-
      log(as.numeric(SingleCellExperiment::counts(cds)[gene_id,]) / size_factors(cds) + 0.1)
    #print(sum(SingleCellExperiment::counts(cds)[gene_id,] > 0))
    is_member <-
      as.character(cell_group_df[colnames(cds),2]) == as.character(cell_group)
    names(is_member) = names(f_expression) = colnames(cds)
    is_member[is.na(is_member)] = FALSE
    is_member[is.null(is_member)] = FALSE

    if (is.null(reference_cells) == FALSE){
      # Exclude cells that aren't in either the cell_group or the
      # reference_panel
      f_expression <- f_expression[is_member | names(f_expression) %in%
                                     reference_cells]
      is_member <- is_member[is_member | names(is_member) %in% reference_cells]
    }

    if (sum(is.na(f_expression)) > 0 || sum(is.na(is_member)) > 0){
      stop("Expression and group membership can't be NA")
    }
    model <- speedglm::speedglm(is_member ~ f_expression,
                                acc=1e-3, model=FALSE,
                                y=FALSE,
                                verbose=TRUE,
                                family=stats::binomial(),
                                maxit=speedglm.maxiter)
    assertthat::assert_that(model$convergence == TRUE, msg=paste0('speedglm model failed to converge in ',speedglm.maxiter, ' iterations.'))
    null_model <- speedglm::speedglm(is_member ~ 1,
                                     acc=1e-3, model=FALSE,
                                     y=FALSE,
                                     verbose=TRUE,
                                     family=stats::binomial(),
                                     maxit=speedglm.maxiter)
    assertthat::assert_that(model$convergence == TRUE, msg=paste0('speedglm null model failed to converge in ',speedglm.maxiter, ' iterations.'))
    lr.stat <- lmtest::lrtest(null_model, model)
    #print (summary(model))
    # #print(summary(null_model))
    # #print (lr.stat)
    #print (str(lr.stat))
    n=ncol(cds)
    pseudo_R2 <-
      (1-exp(-as.numeric(lr.stat$Chisq[2])/n)) /
      (1-exp(2*as.numeric(stats::logLik(null_model)/n)))
    LR_test_pval = lr.stat$`Pr(>Chisq)`[2]
    # model_summary = summary(model)
    # #print(model_summary)
    # #pval = as.numeric(as.character(model_summary$coefficients[2,4]))
    # pseudo_R2
    #pval
    return (list(pseudo_R2, LR_test_pval))
  }, error = function(e) { return(list(0.0, 1.0)) })

  #print(pval)
  return(results)
}

#' Generate a Garnett marker file from top_markers output.
#'
#' @param marker_test_res Tibble of top markers, output of
#'   \code{\link{top_markers}}.
#' @param file Path to the marker file to be generated. Default is
#'   "./marker_file.txt".
#' @param max_genes_per_group Numeric, the maximum number of genes to output
#'   per cell type entry. Default is 10.
#' @param remove_duplicate_genes Logical indicating whether marker genes that
#'   mark multiple cell groups should be excluded. Default is FALSE. When
#'   FALSE, a message will be emitted when duplicates are present.
#'
#' @return None, marker file is written to \code{file} parameter location.
#' @export
#'
generate_garnett_marker_file <- function(marker_test_res,
                                         file = "./marker_file.txt",
                                         max_genes_per_group = 10,
                                         remove_duplicate_genes = FALSE) {
  group_name <- marker_score <- NULL # no visible binding
  marker_test_res <- as.data.frame(marker_test_res)
  if(is.null(marker_test_res$group_name)) {
    marker_test_res$group_name <- paste("Cell type", marker_test_res$cell_group)
  }
  group_list <- unique(marker_test_res$group_name)

  good_markers <- marker_test_res %>% dplyr::group_by(group_name) %>%
    dplyr::top_n(max_genes_per_group, marker_score)

  dups <- good_markers$gene_id[duplicated(good_markers$gene_id)]

  if ("gene_short_name" %in% colnames(good_markers)) {
    dups_gsn <- good_markers$gene_short_name[duplicated(good_markers$gene_short_name)]
  }


  if(remove_duplicate_genes) {
    good_markers <- good_markers[!good_markers$gene_id %in% dups,]
  } else {
    if (length(dups) > 0) {
      if("gene_short_name" %in% colnames(good_markers)) {
        message("The following marker genes mark multiple cell groups. ",
                "Prior to using Garnett, we recommend either excluding ",
                "these genes using remove_duplicate_genes = TRUE, or ",
                "modifying your marker file to make the cell types with ",
                "the shared marker subtypes in a hierarchy. ",
                paste(dups_gsn, collapse = ", "))
      } else {
        message("The following marker genes mark multiple cell groups. ",
                "Prior to using Garnett, we recommend either excluding ",
                "these genes using remove_duplicate_genes = TRUE, or ",
                "modifying your marker file to make the cell types with ",
                "the shared marker subtypes in a hierarchy. ",
                paste(dups, collapse = ", "))
      }
    }
  }

  output <- list()

  for (group in group_list) {
    if (sum(good_markers$group_name == group) == 0) {
      message(group, " did not have any markers above the q-value ",
              "threshold. It will be skipped.")
      next
    }

    good_name <- gsub("\\(|\\)|:|>|,|#", ".", group)
    if (good_name != group) {
      warning("Group name contained an illegal character for a Garnett ",
              "marker file. ", group, " will be substituted for ",
              good_name, ".")
    }

    sub <- good_markers[good_markers$group_name == group,]
    if (nrow(sub) > max_genes_per_group) {
      if(max_genes_per_group < 1) warning('bad loop: max_genes_per_group < 1')
      sub <- sub[order(sub$marker_test_q_value),][1:max_genes_per_group,]
    }
    if ("gene_short_name" %in% colnames(sub)){
      entry <- paste0("> ", good_name, "\n", "expressed: ",
                      paste(sub$gene_short_name, collapse = ", "), "\n")
    } else {
      entry <- paste0("> ", good_name, "\n", "expressed: ",
                      paste(sub$gene_id, collapse = ", "), "\n")
    }

    output <- append(output, entry)
  }

  all <- paste(output, collapse = "\n")

  write(all, file=file)
  message("Garnett marker file written to ", file)
}


# get singler annot labels for plotting
get_singler_annot_label <- function(cds, annot, lvl) {
  level = lvl
  dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>%
    dplyr::mutate(lvl = get(lvl), annot = get(annot)) %>%
    dplyr::group_by(lvl, annot) %>%
    dplyr::count() %>%
    dplyr::group_by(lvl) %>%
    dplyr::mutate(total = sum(n),
                  prop = n / sum(n) * 100,
                  label = paste0(annot, " (", round(prop, 0), "%)")) %>%
    dplyr::filter(prop == max(prop) & prop > 50 | max(prop) < 50 & rank(-prop, ties.method = "min") <= 2) %>%
    dplyr::arrange(-prop) %>%
    dplyr::summarise(label = paste0(level, " ", unique(lvl), " (n = ", unique(total), ")\n", paste(label, collapse = "\n"))) %>%
    {dplyr::left_join(dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>% dplyr::transmute(lvl = get(lvl)), multiple = "all", ., by = "lvl")} %>%
    dplyr::pull(label)
}

# plot all markers in the marker list (marker_list is a named list of marker modules)
plot_markers_on_umap <- function(object, ml, final_umap) {

  p <- final_umap

  purrr::walk(ml, function(g) {

    # get ranges for colour gradient
    if (class(object)[1] == "Seurat") {
      dat <- object@assays$RNA@counts[g, object@assays$RNA@counts[g,] > 0]
    } else if (class(object)[1] == "cell_data_set") {
      dat <- object@assays@data$counts[g, object@assays@data$counts[g,] > 0]
    }
    minmax <- range(dat, na.rm = T)

    # plot
    p[[g]] <<-
      dittoSeq::dittoDimPlot(object, g, size = 0.3, xlab = NULL, ylab = NULL) +
      ggplot2::geom_point(data =  dplyr::tibble(x = SingleCellExperiment::reducedDims(object)$UMAP[names(dat), 1],
                                                y = SingleCellExperiment::reducedDims(object)$UMAP[names(dat), 2]) %>%
                            dplyr::mutate(count = dat) %>%
                            dplyr::as_tibble(),
                          ggplot2::aes(x, y, colour = count), size = 0.4) +
      ggplot2::scale_colour_gradientn(colours = c("grey", "#2374B0", "#ECE147"),
                                      values = scales::rescale(c(0, minmax[1], minmax[2]))) +
      umap_void_theme

    })

  # create grob layout
  p <-
    gridExtra::marrangeGrob(grobs = p,
                            ncol = 4,
                            nrow = ceiling(length(p) / 4),
                            top = NULL)
  return(p)
}

# get cluster centroids from a Seurat or cell_data_set object
get_centroids <- function(object, reduction, lvl) {

  if (class(object)[1] == "Seurat") {
    embeddings <- object@reductions[[reduction]]@cell.embeddings
    metadata <- object@meta.data
  } else if (class(object)[1] == "cell_data_set") {
    embeddings <- SingleCellExperiment::reducedDims(object)[[reduction]]
    metadata <- SummarizedExperiment::colData(object) %>% dplyr::as_tibble()
  }

  dplyr::tibble(
    x = embeddings[,1],
    y = embeddings[,2],
    metadata
  ) %>%
    dplyr::group_by(get(lvl)) %>%
    dplyr::summarise(x = median(x), y = median(y)) %>%
    dplyr::rename(!!lvl := `get(lvl)`)

}

# calculate plot height for grids
get_fig_dims <- function(n_plots, n_cols = NULL, grid_width = 10, height_to_width_ratio = 1) {
  # get dims
  dims <- ggplot2::wrap_dims(n_plots, n_cols)
  # get scale
  scale <- grid_width / dims[1]
  # get height
  grid_height <- (dims[2] * scale) * height_to_width_ratio
  # return dims
  c(grid_width, grid_height)
}
```

# Run info {-}

```{r curr_params, echo = F}
curr_params %>%
  flatten_list() %>%
  {tibble::tibble(
    param = names(.), 
    value = purrr::map(., paste, collapse = ", ") %>% unlist() %>% substr(1, 250))
  } %>%
  knitr::kable()
```

# Load object

```{r load_seu}
cds <- readRDS(params$rds_file)
```

# Top markers

Once cells have been clustered, we can isolate genes that are highly differentially expressed between the clusters. These cluster marker genes can indicate active programmes.

First, we identify the top genes that are most specifically expressed in each cluster and each partition. 

```{r cluster_markers, eval = T, results = F, warning = F, message = F}
# monocle3::top_markers has a bug, so this function doesn't work:
# marker_test_res <- monocle3::top_markers(cds, group_cells_by = "cluster", reference_cells = 1000)
lvls <- c("cluster", "partition")

top_cluster_markers <- xfun::cache_rds({

  # using a debugged version of the function top_markers()
  cds_markers <- 
    lvls %>%
    purrr::map(function(lvl) {
      top_markers_develop(cds, group_cells_by = lvl, genes_to_test_per_group = 100)
    }) %>%
    setNames(lvls)
  
  # get top 3 markers per cluster/partition
  top_cluster_markers <- 
    cds_markers %>%
    purrr::map(function(lvl) {
      lvl %>%
        dplyr::as_tibble() %>%
        dplyr::filter(fraction_expressing >= 0.10) %>%
        dplyr::group_by(cell_group) %>%
        dplyr::arrange(desc(as.numeric(cell_group))) %>%
        dplyr::top_n(3, pseudo_R2)
  })
  
  top_cluster_markers
  
}, file = "top_cluster_markers.rds")

# write out top 3 per cluster
readr::write_tsv(top_cluster_markers %>% dplyr::bind_rows(.id = "cell_grouping"), 
                 "top_3_markers.tsv")
```

```{r top_markers, eval = T, class.source = 'fold-hide', fig.dim = c(10, dplyr::n_distinct(monocle3::clusters(cds))), fig.cap = "Plot of the mean expression across cells and percentage of cells in each group that express the top 3 marker genes of each group"}
p <- 
  lvls %>%
  purrr::map(function(lvl) {
    dittoSeq::dittoDotPlot(
      cds, 
      vars = top_cluster_markers[[lvl]] %>% dplyr::pull(gene_id) %>% unique(),
      group.by = lvl,
      x.labels.rotate = F) +
    ggplot2::coord_flip() +
    ggplot2::theme(text = ggplot2::element_text(size = 8))
  }) %>%
  gridExtra::marrangeGrob(nrow = 1, ncol = 2, top = NULL)
p
```

# Celltype annotation

The conventional approach to celltype annotation for sc/snRNAseq datasets is to inspect known marker genes from each of the celltypes that are expected and likely to be found at the sample site. Known relationships between marker genes and celltypes of interest can be obtained from databases or manually curated from literature. Then, the expression profiles of all markers from all celltypes across all clusters is programmatically or visually inspected and clusters are labelled according to their marker profile. 

## Automated celltype annotation using database markers

The package `SingleR` returns "the best annotation for each cell in a test dataset, given a labelled reference dataset in the same feature space". Using the human primary cell atlas from `celldex`, we can find the nearest reference celltype to each nucleus in the dataset. This approach is good because it is unbiased and does not require manual assignment, but it is unclear how well snRNAseq output will map onto a scRNAseq atlas. Additionally, the reference dataset from `celldex` is more rigid, cannot be customised to the use case, and does not contain transformed celltypes.

Some annotations will contain very few nuclei. These are usually not of interest and clutter up plotting, so we remove annotations assigned to < 10 nuclei.

```{r singler_annots, message = F, warning = F}
singler_refs <- celldex::BlueprintEncodeData()

cds_singler <- xfun::cache_rds({
  cds_singler <- SingleR::SingleR(
    test = cds@assays@data$counts,
    ref = singler_refs,
    labels = colnames(singler_refs))
  cds_singler
}, file = "cds_singler.rds")

cds <- xfun::cache_rds({
  # add singler annotation
  SummarizedExperiment::colData(cds) <- 
    SummarizedExperiment::colData(cds) %>%
    cbind(
      cds_singler %>%
        dplyr::as_tibble() %>%
        dplyr::select(singler_annot_fine = labels) %>%
        dplyr::group_by(singler_annot_fine) %>%
        dplyr::left_join(
          SummarizedExperiment::colData(singler_refs) %>%
            tibble::as_tibble(rownames = "singler_annot_fine") %>%
            dplyr::select(singler_annot_fine, singler_annot_main = label.main))
        )
  # add main/fine labels for partitions/clusters
  for (lvl in c("cluster", "partition")) {
    for (annot in c("singler_annot_fine", "singler_annot_main")) {
      SummarizedExperiment::colData(cds)[, paste(lvl, annot, sep = "_")] <-
        get_singler_annot_label(cds, annot, lvl)
    }
  }
  # return
  cds
}, file = "cds_singler_annotated.rds")
```

```{r save_singler}
saveRDS(cds, "cds_singler_annotated.rds")
```

```{r singler_annot_fine_heatmap, class.source = 'fold-hide', fig.width = 10, fig.cap = "Heatmap of fine celltype annotation scores from SingleR"}
annotation_col <- 
  SummarizedExperiment::colData(cds)[, c("cluster", "partition", "singler_annot_main")] %>% 
  as.data.frame()
if (dplyr::n_distinct(SummarizedExperiment::colData(cds)$patient_id, na.rm = T) > 1) {
  annotation_col$patient_id <- SummarizedExperiment::colData(cds)$patient_id
}
if (dplyr::n_distinct(SummarizedExperiment::colData(cds)$lesion_type, na.rm = T) > 1) {
  annotation_col$lesion_type <- SummarizedExperiment::colData(cds)$lesion_type
}
cds_singler$main_labels <- SummarizedExperiment::colData(cds)$singler_annot_main
p <-
  SingleR::plotScoreHeatmap(
    cds_singler, 
    show.labels = F,
    annotation_col = annotation_col,
    fontsize_row = 7)
p
```

```{r umap_vs_singler_annots, class.source = 'fold-hide', results = F, fig.width = 10, fig.height = 10, fig.cap = "Plot of UMAP clusters, coloured by SingleR annotation and labelled by the major SingleR annotation(s) per cluster"}
p <- list()
purrr::walk(c("cluster", "partition"), function(lvl) {
  purrr::walk(c("singler_annot_fine", "singler_annot_main"), function(annot) {
    label_col <- paste(lvl, annot, sep = "_")
    p_i <-
      dittoSeq::dittoDimPlot(cds, annot, main = gsub("_", " ", label_col), size = 0.7) +
      ggrepel::geom_label_repel(
        data = 
          dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>%
          dplyr::select(dplyr::all_of(c(lvl, label_col))) %>%
          dplyr::right_join(get_centroids(cds, "UMAP", lvl), by = lvl) %>%
          dplyr::distinct(),
        ggplot2::aes(x, y, label = get(label_col)),
        min.segment.length = 0,
        size = 1.5, fill = 'white', alpha = 0.8, seed = 1234, label.size = NA
      ) 
    p[[label_col]] <<- p_i + umap_void_theme 
  })
}) 
patchwork::wrap_plots(p)
```

```{r singler_annots_bar, class.source = 'fold-hide', fig.cap = "Plot of SingleR annotation composition of samples"}
p <-
  dittoSeq::dittoBarPlot(
  cds,
  var = "singler_annot_main",
  group.by = "sample",
  scale = "count",
  main = "",
  legend.show = F
  ) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, size = 5),
                 legend.text = ggplot2::element_text(size = 5)) +
  SummarizedExperiment::colData(cds) %>%
  tibble::as_tibble() %>%
  ggplot2::ggplot(ggplot2::aes(x = cluster, fill = singler_annot_main)) +
  ggplot2::geom_bar() + 
  ditto_colours +
  ggplot2::theme_classic() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, size = 5),
                 legend.text = ggplot2::element_text(size = 5),
                 legend.title = ggplot2::element_blank()) +
  patchwork::plot_layout(
    ncol = 2,
    widths = c(
      SummarizedExperiment::colData(cds)$sample %>% dplyr::n_distinct(),
      SummarizedExperiment::colData(cds)$cluster %>% dplyr::n_distinct()
    )
  )
p
```

```{r singler_annots_alluvial, class.source = 'fold-hide', fig.width = 10, fig.cap = "Alluvial plot of assignment paths of nuclei from samples to clusters to partitions to SingleR annotations, coloured by cluster"}
# TODO: # fix this!!!
p <-
  dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>%
  dplyr::group_by(sample, partition, cluster, singler_annot_main) %>%
  dplyr::count() %>%
  dplyr::ungroup() %>%
  ggforce::gather_set_data(1:4) %>%
  dplyr::mutate(x = dplyr::case_when(x == 1 ~ "sample",
                                     x == 2 ~ "partition",
                                     x == 3 ~ "cluster",
                                     x == 4 ~ "singler_annot_main") %>%
                  factor(levels = c("sample", "partition", "cluster", 
                                    "singler_annot_main"))) %>%
  ggplot2::ggplot(ggplot2::aes(
                    x = x,
                    id = id,
                    split = y,
                    value = n
                  )) +
  ggforce::geom_parallel_sets(ggplot2::aes(fill = cluster),
                              axis.width = 0.15,
                              alpha = 0.75) +
  ggforce::geom_parallel_sets_axes(fill = "lightgrey",
                                   axis.width = 0.15) +
  ggforce::geom_parallel_sets_labels(angle = 0, 
                                     nudge_x = c(
                                       rep(-0.3, dplyr::n_distinct(SummarizedExperiment::colData(cds)$sample)),
                                       rep(0, dplyr::n_distinct(SummarizedExperiment::colData(cds)$partition)),
                                       rep(0, dplyr::n_distinct(SummarizedExperiment::colData(cds)$cluster)),
                                       rep(0.4, dplyr::n_distinct(SummarizedExperiment::colData(cds)$singler_annot_main))
                                     )) +
  ggplot2::theme_void() +
  ggplot2::theme(legend.position = "none",
                 axis.text.x = ggplot2::element_text(face = "bold", size = 15)) +
  ditto_colours
p
```

## Manual celltype annotation using curated literature markers

`r if (curr_params$annotating$markers_file == F) {"No markers_file given." }`

```{r exit_if_no_markers, eval = curr_params$annotating$markers_file == F, include = F}
knitr::knit_exit()
```

```{r cds_avail_markers, echo = F}
# load markers
markers <-
  curr_params$annotating$markers_file %>%
  readr::read_tsv(show_col_types = F) %>%
  {split(.$gene, .$population)}
# get markers present in the dataset
avail_markers <- markers %>% purrr::map(intersect, rownames(cds))
```

`r length(unique(unlist(markers)))` marker genes across `r length(markers)` celltypes / annotations were provided.

`r length(unique(unlist(avail_markers)))` of these marker genes are present in the dataset.

```{r all_modules_heatmap, echo = F, warning = F, message = F, fig.dim = c(10, length(avail_markers) / 2), fig.cap = "Heatmap of all module scores for all monocle3 clusters"}
df <- 
  avail_markers %>%
  purrr::map(dplyr::as_tibble) %>%
  dplyr::bind_rows(.id = "module") %>%
  dplyr::distinct() %>%
  dplyr::mutate(unique_module = module) %>%
  dplyr::group_by(unique_module) %>%
  dplyr::mutate(module_size = dplyr::n_distinct(value),
                module = paste0("(", module_size, ") ", module)) %>%
  dplyr::ungroup()

# genes, grouped into modules
gene_group_df <- 
  df %>% 
  dplyr::select(value, unique_module) 

# cells, grouped into clusters and partitions
cell_group_df <- 
  tibble::tibble(
    cell = row.names(SummarizedExperiment::colData(cds)), 
    cluster = monocle3::clusters(cds),
    partition = monocle3::partitions(cds))

# col annotations (cluster, partition)
col_annotations <-
  cell_group_df %>%
  dplyr::distinct(cluster, partition) %>%
  tibble::column_to_rownames("cluster")

# get row and col annotation colours
colours <- 
  list(partition = col_annotations$partition) %>%
  purrr::map(function(i) {
    dittoSeq::dittoColors()[1:length(unique(i))] %>%
      setNames(unique(i))
    }
  )

# check if >1 partition / cluster
multiple_partitions <- dplyr::n_distinct(cell_group_df$partition) > 1
multiple_clusters <- dplyr::n_distinct(cell_group_df$cluster) > 1
```

### Modules vs clusters

```{r modules_vs_clusters_heatmap, eval = multiple_clusters == T, echo = F, warning = F, message = F, fig.dim = c(10, 20), fig.cap = "Heatmap of all module scores for all monocle3 clusters"}
agg_mat <- xfun::cache_rds({
  monocle3::aggregate_gene_expression(
    cds, 
    gene_group_df, 
    cell_group_df[, c("cell", "cluster")])
}, file = "agg_mat.rds")
  
p <-
  pheatmap::pheatmap(agg_mat, scale = "row", clustering_method = "ward.D2",
                     annotation_col = col_annotations,
                     annotation_colors = colours, border_color = NA)
p
```

### Modules vs partitions

```{r modules_vs_partitions_heatmap, eval = multiple_partitions == T, echo = F, warning = F, message = F, fig.dim = c(10, 15), fig.cap = "Heatmap of all module scores for all monocle3 partitions"}
agg_mat <- 
  monocle3::aggregate_gene_expression(
    cds, 
    gene_group_df, 
    cell_group_df[, c("cell", "partition")])
p <-
  pheatmap::pheatmap(agg_mat, scale = "row", clustering_method = "ward.D2",
                     annotation_colors = colours, border_color = NA)
p
```

```{r knit_module_plots, echo = FALSE, warning = F, message = F, results = 'asis'}
to_knit <- c()
agg_mat <- list()
genes <- list()
cell_group_df <- list()

final_umap <- 
  lvls %>%
  purrr::map(function(lvl) {
    dittoSeq::dittoDimPlot(cds, lvl, size = 0.5, xlab = NULL, ylab = NULL) +
    ggplot2::geom_label(
      data = SummarizedExperiment::colData(cds) %>%
        dplyr::as_tibble() %>%
        dplyr::right_join(get_centroids(cds, "UMAP", lvl), by = lvl) %>%
        dplyr::distinct(get(lvl), x, y),
      ggplot2::aes(x, y, label = `get(lvl)`),
      size = 3, fill = "white", alpha = 0.7, label.size = NA) +
    umap_void_theme
  })  

for(ct in names(avail_markers)) {
  
  to_knit <- c(to_knit, paste0("\n##### Population: **", ct, "**\n"))
  chunk_name_ct <- ct %>% janitor::make_clean_names()
  ct_markers <- avail_markers[[ct]]
  n_ct_markers <- length(ct_markers)
  
  for(lvl in lvls) {

    chunk_name_lvl <- paste(chunk_name_ct, lvl) %>% janitor::make_clean_names()

    if (dplyr::n_distinct(SummarizedExperiment::colData(cds)[, lvl]) > 1 & 
        n_ct_markers > 1) {
      
      genes[[chunk_name_lvl]] <- avail_markers[[ct]]
      cell_group_df[[chunk_name_lvl]] <-
        tibble::tibble(cell = row.names(SummarizedExperiment::colData(cds)),
                       cell_group = SummarizedExperiment::colData(cds)[, lvl],
                       partition = monocle3::partitions(cds))
      agg_mat[[chunk_name_lvl]] <-
        monocle3::aggregate_gene_expression(
          cds[genes[[chunk_name_lvl]], ],
          cell_group_df = cell_group_df[[chunk_name_lvl]][, c("cell", "cell_group")])
      knit_lvl_module_heatmap <- c(
        '',
        paste0('```{r ', chunk_name_lvl, '_gene_heatmap, class.source = "fold-hide",  warning = F, message = F, fig.dim = c(10, max(length(genes[[chunk_name_lvl]]) / 6, 2))}'),
        paste0('p <- pheatmap::pheatmap(agg_mat[["', chunk_name_lvl, '"]], scale = "row", clustering_method = "ward.D2", fontsize = 6', ifelse(n_ct_markers == 1, ", cluster_rows = F", ""), ')'),
        'p',
        '```',
        ''
        )
      } else {
        knit_lvl_module_heatmap <- paste0(
          "Only one ", ifelse(n_ct_markers == 1, "gene", lvl), " so cannot produce a heatmap!\n")
      }
    
    dev_off_if()
    knitted_lvl_module_heatmap <- knitr::knit_child(text = knit_lvl_module_heatmap, envir = environment(), quiet = TRUE)
    dev_off_if()
    to_knit <- c(to_knit, knitted_lvl_module_heatmap)
  
  }

  if(n_ct_markers < 50) {
    knit_module_dimplots <- c(
      '',
      paste0('```{r ', chunk_name_ct, ', echo = F, warning = F, message = F, fig.dim = get_fig_dims((n_ct_markers + 2), n_cols = 4, height_to_width_ratio = 1.2)}'),
      'p <- plot_markers_on_umap(cds, ml = ct_markers, final_umap)',
      'p',
      '```',
      ''
      )
  } else {
    knit_module_dimplots <- paste(n_ct_markers, "markers in this set - too many to print!\n")
  }

  dev_off_if()
  knitted_module_dimplots <- knitr::knit_child(text = knit_module_dimplots, envir = environment(), quiet = TRUE)
  dev_off_if()
  to_knit <- c(to_knit, knitted_module_dimplots)

}
dev_off_if()
cat(unlist(to_knit), sep = '\n')
```

# Final cluster annotations

```{r summarise_annots, include = F, warning = F}
cell_groupings_summary <- xfun::cache_rds({
  
  cell_groupings <-
    dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>%
    tidyr::pivot_longer(c("cluster", "partition"), names_to = "cell_grouping", values_to = "cell_group")
  
  if (multiple_partitions == F) {
    cell_groupings <-
      cell_groupings %>%
      dplyr::filter(cell_grouping != "partition")
  }
  
  # counts
  cell_groupings_summary <-
    cell_groupings %>% 
    dplyr::group_by(cell_grouping, cell_group) %>%
    dplyr::count() 
  
  # add percent by lesion type
  if ("lesion_type" %in% names(cell_groupings)) {
    cell_groupings_summary <-
      cell_groupings_summary %>%
      dplyr::left_join(
      cell_groupings %>%
        dplyr::group_by(cell_grouping, cell_group, lesion_type) %>%
        dplyr::count() %>% 
        dplyr::group_by(cell_grouping, cell_group) %>%
        dplyr::mutate(prop = n / sum(n)) %>%
        tidyr::pivot_wider(names_from = lesion_type, values_from = prop, id_cols = dplyr::starts_with("cell_group")),
      by = c("cell_grouping", "cell_group")
    ) 
  }
  
  # add percent by singler annot
  cell_groupings_summary <-
    cell_groupings_summary %>%
    dplyr::left_join(
      # singler_annots
      cell_groupings %>%
        tidyr::pivot_longer(dplyr::starts_with("singler_annot_")) %>%
        dplyr::group_by(cell_grouping, cell_group, name, value) %>%
        dplyr::count() %>% 
        dplyr::group_by(cell_grouping, cell_group, name) %>%
        dplyr::mutate(prop = n / sum(n) * 100,
                      label = paste0(value, " (", round(prop, ifelse(prop < 1, 1, 0)), "%)")) %>% 
        dplyr::filter(prop > 10) %>%
        dplyr::arrange(-prop) %>%
        dplyr::summarise(value = paste(label, collapse = ", ")) %>%
        tidyr::pivot_wider(),
      by = c("cell_grouping", "cell_group")
    ) %>%
    dplyr::left_join(
      # top_cluster_markers
      top_cluster_markers %>%
        dplyr::bind_rows(.id = "cell_grouping") %>%
        dplyr::group_by(cell_grouping, cell_group) %>% 
        dplyr::summarise(top_markers = paste(gene_id, collapse = ", ")),
      by = c("cell_grouping", "cell_group")
    )
  
  cell_groupings_summary
  
}, file = "cell_groupings_summary.rds")

knitr::kable(cell_groupings_summary, digits = 3)
```

# Final celltype annotations

`r if (curr_params$annotating$annotations_file == F) {"No annotations_file given." }`

```{r exit_if_no_annots, eval = curr_params$annotating$annotations_file == F, include = F}
knitr::knit_exit()
```

```{r load_annots}
annots <- 
  curr_params$annotating$annotations_file %>%
  readr::read_tsv() %>%
  dplyr::mutate(dplyr::across(everything(), as.factor))
```

Provided celltype annotations include `r length(unique(annots$annotation))` celltypes. They annotate the cells based on the *`r intersect(colnames(annots), colnames(SummarizedExperiment::colData(cds)))`* column of the colData.

```{r show_annots, include = F}
knitr::kable(annots)
```

```{r annotate_celltypes}
cds <- xfun::cache_rds({
  SummarizedExperiment::colData(cds) <-
    cbind(
      SummarizedExperiment::colData(cds),
      SummarizedExperiment::colData(cds) %>%
        tibble::as_tibble(rownames = "cell") %>%
        dplyr::left_join(annots) %>%
        dplyr::select(annotation)
    )
  cds
}, file = "cds_celltype_annotated.rds")
```

```{r save}
saveRDS(cds, "cds_celltype_annotated.rds")
```